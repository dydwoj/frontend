<< JS (Java Script) >>
    => 동적 작업 담당
        ex. 버튼 클릭시 메세지 띄우기
    => HTML 안에 작성 가능 : 웹페이지를 불러올 때, 스크립트가 자동 실행
    => 코드는 java 언어와 비슷함
    => 서버에서도 실행 가능 : NodeJS (JS를 서버쪽으로 실행가능하게 만든 것)
    => 자바스크립트 실행(런타임)환경
        1) 브라우저
        2) Node.js
            => 폴더를 기준으로 open in integrated terminal 실행
            => 터미널에 node 파일명.js 입력
            => .js 파일 실행함

    * 위에서 아래로 실행됨
    * 주석 : // (자바와 같음)
    * ( ; ) 의 사용이 필수가 아님
        => 줄바꿈이 있다면 세미콜론 생략가능
        => 엔터의 유무에 따라 js가 알아서 넣어줌
    * '', "" : 둘다 허용 => 문자열 취급
    * ISO 8601 표준표현방법(시간) : 2025-04-07T01:07:21.864Z
    * document.write() : 화면단(body) 에 결과값 찍기
        => 태그 사용 가능
            ex. <h3><h3>, <h2><h2> 등...
    * 디버깅 걸기
        => 실행 후 F12 => 확인 원하는 줄 클릭 => 상단 주소 enter로 재실행 => F10으로 따라가기
    * `` => 자판의 ( ~ )이랑 같이 있는 기호
    * 터미널 멈추기 : ctrl + c

    - 선언위치
        => 선언의 위치 중요!
        1) head tag 안
        2) body tag 안
            => /body(닫는body) 앞쪽에 선언


        - 방법
            1) inline
                ex. <button type="button" onclick="alert('버튼을 클릭했습니다')">클릭</button>
            2) 외부링크
                ex. <script src="script.js"></script>

    - 변수 (feat.상수)
        참고 : 2.변수
        => 타입이 존재 X
        => 같은 변수명에 타입을 여러개 담을 수 없음

        - but. 딱 3개만 존재 why? 변수에 값을 담으면 타입이 생김
            => 변수를 담으면 js 에서 알아서 타입을 설정
            1) let : 변수
            2) const : 상수
                => 변하면 안되는 값들을 담을 때 사용
            3) var (예전방식)
                => 유연한 변수선언 방식

            - function scope : var
                => function 안에서 선언된 값만 부를 수 없게 해놨고 나머진 상관이 없다
                => 오류시, 오류를 찾기 힘들어지는 경우가 생김
            - block-scope : let, const
                => 자바의 지역변수와 같은 내용
                => { } : 같은 변수명이어도 블럭 바깥과 안의 유무에 따라 사용가능
                => 변수 사용의 범위를 명확하게 함
        
        - use strict
            => 상단에 작성
            => 문법의 정확성을 위한 것

        - 변수 범위
            => java의 변수 선언의 범위와 같음
    
    - 자료형
        참고 : datatype

        1) number : 숫자형
        2) string : 문자형
        3) 불린형
        4) null
        5) undefined
            => 선언만 하고 값이 없는 상황
        6) object

    - 연산자
        참고 : operator

        - 산술연산자
            +, -, *, /, %
                    => js 는 / 계산에서 소숫점 1자리 까지 나옴 but. 자바 : 몫만 나옴
        - 연결연산자
            + : 연결 연산자
                ex. 숫자 + 문자 : 연결
            -, /, *, % : 문자와 숫자의 산술연산
                => 연산이 가능! => + 만 연결로 감!
        - 비교연산자
            == : 값 비교
            != : 값 비교 (부정)
            === : 값/타입 비교
            !== : 값/타입 비교 (부정)

        단항연산자
            ++, --

    - 상호작용 함수
        참고 : prompt

        * web 에서 입력들어오는 모든값의 타입 : String

        1) alert() : 사용자에게 메세지 전달
        2) prompt() : 사용자로부터 입력 받기
            => ( , ) : , 앞에 메세지 띄우고 뒤에 기본값을 입력할 수도 있음
            => 입력값 : String
                => 입력값이 string 이기에 + 는 산술이 안되고 연결을 함
        3) confirm : 사용자에게 메세지 전달후 확인/취소 선택
            => 확인 선택 : true
            => 취소 선택 : false

    - 조건문
        참고 : condition, if1,2,3

        true : true 자료들, 0 제외 숫자, '문자', [], {}
        false : false 자료들, 0, '', null, undefined, NaN

            - NaN (Not a Number) : 
                => 숫자 : false
                    => "" 문자열숫자도 숫자로 인식
                => 숫자 제외 : true
                * isNaN() : 숫자 판별기
            - 삼항연산자도 사용가능
            
        * 문자열숫자 => 숫자
            ex. "12" => 12

            1) Number()
                => 문자열을 집어넣을 경우 : NaN 리턴
                => 문자열숫자 여러개 입력시 => NaN
                    ex. Number(78 45 55) => NaN
            2) parseInt()
                => 문자열을 집어넣을 경우 : NaN 리턴
                => 소수점 아래 숫자들을 자른다
                    ex. parseInt(78.65) => 78
                => 문자열숫자 여러개 입력시 => 공백 기준 첫번쨰 숫자만 나옴
                    ex. parseInt("78 45 55") => 78
    
    - 반복문
        참고 : loop

        - for
            1) fori
            2) foreach
                자바 : ->
                JS : =>
            3) for in : 객체 출력에 용이함
                * 객체 담기 : {key: value}
                    key/value 란?
                    => key: value
                * `${변수명}` : 변수 + 문자열 출력시 사용
            4) for of
                => js에서의 향상된 for문 형태
                    => java의 향상된 for문과 같음

        - while
            1) while
            2) doWhile

        - break
            => 반복문 중단
        - continue
    
    - 배열
        참고 : array

        - 배열 생성
            1) 타입 배열명 = [];
                => 다른 타입을 담아도 무관!
            2) 타입 배열명 = new Array();

        - 배열 조회
            1) fori
            2) for of
            3) foreach
            4) 확인용
                => console.log(배열명)
            5) toString
                => console.log(배열명.toString()) : 배열 => 문자열

        - 메서드
            참고 : array2

            1) .length : 길이
            2) .toString() : 배열 => 문자열
            3) .배열명[숫자] : 숫자 순서의 배열 출력
            4) .at(숫자) : 숫자 순서의 배열 출력

            - 추가
            5) push(item) : 뒤에 추가
            6) unshift(item) : 앞에 추가
            7) 배열명[숫자] = item : 해당 숫자 순서의 배열 수정
            8) splice(위치, 삭제할개수, item)
                => 삭제할 개수가 있는 경우 : 해당 위치에 삭제할 개수를 지정해서 삭제
                => 삭제할 개수가 0인 경우 : 삭제 없이 비집고 들어가기

            - 삭제
            9) pop() : 뒤에서 삭제
            10) shift() : 앞에서 삭제
            11) splice(위치, 삭제할 개수)

            - 그 외
                참고 : array3
            12) join() : String 으로 반환
                => toString 은 , 로만 연결
                => () 안에 문자를 넣으면 => item 사이에 넣은 문자 넣고 string 으로 출력
                    => , 이외의 값으로 연결하고 싶은 경우
            13) concat(배열명) : 배열 연결
            14) slice(처음, 끝) : 처음~끝 까지 따로 분할
                => 끝 번호는 포함 X
            15) sort() : 배열 정렬
                => 숫자 정렬시, 숫자의 첫번째 숫자만을 가지고 정렬함
                    ex. 22, 35, 1, 3, 7, 88, 92 => 1,22,3,35,7,88,92
                * 숫자 배열 정렬
                    - .sort((a, b) => a - b) : 오름차순
                    - .sort((a, b) => b - a) : 내림차순
                        => 화살표 함수 사용!
            16) .reverse() : 배열 거꾸로 출력
            17) .indexOf() : 배열 안에서 index 찾기
                => 해당 위치 숫자 리턴
                => 못찾으면 -1 리턴
                lastIndexOf
            18) includes(item) : 해당 item의 포함여부 확인
                => true, false 로 반환
            19) find(조건) : 조건에 해당하는 것을 넣어서 찾기 (화살표 함수 사용)
                => 자바의 predicate 함수와 같음
                => 1개의 값만 찾아옴
            20) findIndex(조건) : 찾기 (화살표 함수 사용)
                => 위 find 의 조건에 일치하는 값 찾고 위치 리턴
            21) map(조건) : 찾기 (화살표 함수 사용)
                => 조건에 맞게 배열 변환 후 새로운 배열로 리턴
            22) flat() : 3차원 배열 => 2차원 배열
                => flat(숫자) : 묶여있는 배열이 숫자만큼 풀려져서 나옴
            23) filter : 조건 검사 (화살표 함수 사용)
                => 조건에 맞는 배열요소 찾아서 새로운 배열로 리턴
        
        - 얕은 복사 / 깊은 복사
            참고 : array3

            - 얕은 복사 (주소 복사)
                let 배열1 = 배열2;
                    => 같은 공간을 가리킴
                    => 배열1 에 변화를 일으키면 배열2에도 영향
            
            - 깊은 복사 (값 복사 => 서로 다른 주소)
                let 배열1 = [...배열2]
                    * ... : spread => 값복사
                    => 배열2의 내용을 새로운 주소값을 부여해서 복사 : 값 복사

        - 동일한 값으로 배열 생성
            참고 : array3

            타입 배열명 = new Array(배열개수).fill(item);
            
        - 배열 합치기
            참고 : array3

            1) concat()
            2) 새로운 배열 = [배열1, 배열2];
                => 3차원 배열이 됨
                => 주소복사

                - 값복사
                    => 배열1, 2 앞에 ...(spread) 붙이기
                    => 위 처럼 3차원 배열이 아닌 값들만 복사가 되므로 2차원 배열이 됨

    - 함수
        참고 : function
        => 함수 == 자바의 메서드

        * function 안의 function은 호출 못함

        - 함수 생성
            1) 함수선언방식
                참고 : function1
                function 이름(매개변수) {
                    해야할 일들 나열
                }
                1. 매개변수가 없는 함수
                2. 매개변수가 있는 함수
                    2-1. console.log 사용
                        => 매개변수는 있는데 값을 안 넣은 경우 => undefined
                    2-2. return 사용
                        => 1. 함수명만 부른 경우 : [Function: mutiply2]
                        => 2. 값을 안 넣은 경우 : NaN
                3. 매개변수 기본값이 있는 함수
            2) 함수표현식
                참고 : function2
                * 함수표현식도 함수이기 때문에 함수명() <- ()괄호 필수!
                1. const 함수명 = function () {};
                2. const 함수명 = function 이름() {};
                    => 호출은 함수명으로만 가능!
                        => 이름은 내부용 => 외부 호출 불가

            - 함수정의방식 비교 (1, 2)
                참고 : function2
                1) 함수선언방식
                    - 호이스팅(hoisting) 허용
                        => 함수를 선언하기 전에 사용
                        => 오류를 잡아내기 힘듬

                    * 호이스팅 허용 형태
                        1. function name() {}
                        2. var 변수
                
                2) 함수표현식
                    - 호이스팅 허용 X

                    * 호이스팅 허용 X 형태
                        1. 함수표현식
                        2. let, const 변수
        
        - 화살표 함수
            참고 : function3

            const name = () => {}
                => function 을 날릴 수 있음
                => 계산 내용이 단순하면 {} 도 날릴 수 있음
        
        - 콜백함수
            참고 : function4, function1.html
            => 함수를 함수의 인자로 전달, 전달된 함수가 나중에 호출
            => 전달인자(매개변수)를 함수로 던지는 것

        - js 내장함수
            참고 : function5

            * 비동기 : 일정한 시간이 지난 뒤에 시작되는 함수식

            1) setTimeout(조건 , 시간(ms)) : 비동기식
                => ms(밀리세컨드) 단위
                => 지정한 시간이 지나야 조건이 실행됨
            2) setInterval(조건, 간격시간(interval)) : 비동기식
                => 지정한 간격마다 조건이 실행됨
            3) parseFloat() : String => float
            4) 인코딩 방식
                1. encodeURI()
                2. encodeURIComponentRI
            5) 디코딩 방식
                1. decodeURI()
                2. decodeURIComponent()